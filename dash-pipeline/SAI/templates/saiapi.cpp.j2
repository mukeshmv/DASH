#include <mutex>
#include <unordered_map>
#include <atomic>
#include <limits>
#include <stdint.h>
#include <PI/pi.h>
#include <grpcpp/grpcpp.h>
#include "p4/v1/p4runtime.grpc.pb.h"
#include "utils.h"
#include "saiexperimental{{ app_name | replace('_', '') }}.h"
#include "saitypes.h"
#include <fstream>
#include <google/protobuf/text_format.h>
#include <google/rpc/code.pb.h>

#if __APPLE__
#include <net/ethernet.h>
#else
#include <netinet/ether.h>
#include <netinet/in.h>
#endif

#define LOG(x) std::cerr<<x

using namespace std;

{% for table in tables %}

{% if table.is_object == 'true' %}
static table_entry_p sai_create_{{ table.name }}__ (
        _In_ sai_object_id_t switch_id,
        _In_ pi_p4_id_t tableId,
        _In_ uint32_t attr_count,
        _In_ const sai_attribute_t *attr_list,
        sai_object_id_t objId) {
    std::unique_ptr<p4::v1::TableEntry> table_entry (new p4::v1::TableEntry());
    auto matchActionEntry = table_entry.get();
        // There shall be one and only one action_type
    auto entry = matchActionEntry->mutable_action();
    auto action = entry->mutable_action();
    auto expectedParams = 0;
    auto matchedParams = 0;
    // Search the action
    pi_p4_id_t actionId;

    matchActionEntry->set_table_id(tableId);

    {% if table['keys'] | length== 1 %}
    // SAI object table with single P4 key - object ID itself is the P4 table key
    // Generate a SAI object ID and fill it as the P4 table key
    auto mf = matchActionEntry->add_match();
    mf->set_field_id({{table['keys'][0].id}});
    auto mf_exact = mf->mutable_exact();
    {{table['keys'][0].sai_key_field}}SetVal(objId, mf_exact, {{table['keys'][0].bitwidth}});
    {% else %}
    // SAI object table with multiple P4 table keys
    // Copy P4 table keys from appropriate SAI attributes
    for (uint32_t i = 0; i < attr_count; i++) {
        switch(attr_list[i].id) {
            {% for key in table['keys'] %}
            case SAI_{{ table.name | upper }}_ATTR_{{ key.sai_key_name | upper }}: {
                auto mf = matchActionEntry->add_match();
                mf->set_field_id({{key.id}});
                {% if key.match_type == 'exact' %}
                auto mf_exact = mf->mutable_exact();
                {{key.sai_key_field}}SetVal(attr_list[i].value, mf_exact, {{key.bitwidth}});
                {% elif key.match_type == 'lpm' %}
                auto mf_lpm = mf->mutable_lpm();
                {{key.sai_lpm_field}}SetVal(attr_list[i].value, mf_lpm, {{key.bitwidth}});
                {% elif key.match_type == 'list' %}
                assert(0 && "mutable_list is not supported");
                goto ErrRet;
                // auto mf1_list = mf1->mutable_xxx();
                //{{key.sai_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
                {% elif key.match_type == 'range_list' %}
                goto ErrRet;
                assert(0 && "range_list is not supported");
                // TODO: if it is ternary, need to set the mask
                // auto mf1_list = mf1->mutable_xxx();
                //{{key.sai_range_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
                {% elif key.match_type == 'optional' %}
                auto mf_optional = mf->mutable_optional();
                {{key.sai_key_field}}SetVal(attr_list[i].value, mf_optional, {{key.bitwidth}});
                {% endif %}
                {% if 'v4_or_v6_id' in key %}
                {
                    // set v4_or_v6 field
                    auto mf = matchActionEntry->add_match();
                    mf->set_field_id({{key.v4_or_v6_id}});
                    auto mf_exact = mf->mutable_exact();
                    booldataSetVal((attr_list[i].value.ipaddr.addr_family == SAI_IP_ADDR_FAMILY_IPV4) ? 0 : 1, mf_exact, 1);
                }
                {% endif %}
                break;
            }
            {% endfor %}
            {% if table['keys'] | selectattr('match_type', 'ne', 'exact') | list | length > 0 %}
            {% if table['keys'] | selectattr('match_type', 'eq', 'lpm') | list | length == 0 %}
            // Table has non lpm ternary keys - add priority field
            case SAI_{{ table.name | upper }}_ATTR_PRIORITY: {
                matchActionEntry->set_priority(attr_list[i].value.u32);
                break;
            }
            {% endif %}
            {% endif %}
        }
    }
    {% endif %}


    // If there is only one action, simply set it.
    // Else, search in the attrs.
    {% if table.actions|length == 1 %}
    {% for action in table.actions %}
    actionId = {{action.id}}; // SAI_{{ table.name | upper }}_ACTION_{{ action.name | upper }}
    expectedParams = {{ action.params|length }};
    {% endfor %}
    {% else %}
    // Search the action 
    for (uint32_t i = 0; i < attr_count; i++) {
        if (attr_list[i].id != SAI_{{ table.name | upper }}_ATTR_ACTION) {
            continue;
        }
        switch(attr_list[i].value.s32) {
            {% for action in table.actions %}
            case SAI_{{ table.name | upper }}_ACTION_{{ action.name | upper }}: {
                actionId = {{action.id}}; 
                expectedParams = {{ action.params|length }};
                break;
            }
            {% endfor %}
        }
        // only one action
        break;
    }
    {% endif %}
    action->set_action_id(actionId);

    for (uint32_t i = 0; i < attr_count; i++) {
        switch(attr_list[i].id) {
            {% for param in table.actionParams %}
            case SAI_{{ table.name | upper }}_ATTR_{{ param.name | upper }}: {
                auto param = action->add_params();
                param->set_param_id({{param.id}});
                {{param.field}}SetVal(attr_list[i].value, param, {{param.bitwidth}});
                matchedParams++;
                {% if 'v4_or_v6_id' in param %}
                {
                    // set v4_or_v6 field
                    auto param = action->add_params();
                    param->set_param_id({{param.v4_or_v6_id}});
                    booldataSetVal((attr_list[i].value.ipaddr.addr_family == SAI_IP_ADDR_FAMILY_IPV4) ? 0 : 1, param, 1);
                    matchedParams++;
                }
                {% endif %}
                break;
            }
            {% endfor %}
        }
    }
    
    assert((matchedParams == expectedParams)); 

    if (matchedParams != expectedParams) {
        goto ErrRet;
    }
    return table_entry;
ErrRet:
    return table_entry_p();
}

sai_status_t sai_create_{{ table.name }}(
        _Out_ sai_object_id_t *{{ table.name }}_id,
        _In_ sai_object_id_t switch_id,
        _In_ uint32_t attr_count,
        _In_ const sai_attribute_t *attr_list) {
    table_entries_t table_entries;
    sai_object_id_t objId = 0;
    objId = NextObjIndex();
    {% if table['stagesTableID']|length > 1 %}
    sai_status_t ret;
    table_entry_p entry_p;
    {% for tableID in table['stagesTableID'] %}
    entry_p = sai_create_{{ table.name }}__( switch_id, {{ tableID }}, attr_count, attr_list, objId);
    if (!entry_p) {
        goto ErrRet;
    }
    table_entries.emplace_back(std::move(entry_p));
    {% endfor %}
    {% else %}
    pi_p4_id_t tableId = {{table.id}};
    auto entry_p = sai_create_{{ table.name }}__( switch_id, {{ table.id }}, attr_count, attr_list, objId);
    if (!entry_p) {
        goto ErrRet;
    }
    table_entries.emplace_back(std::move(entry_p));
    {% endif %}
    // TODO: ternaly needs to set priority
    if (true == InsertInTable(std::move(table_entries), &objId)) {
        *{{ table.name }}_id = objId;
        return 0;
    }
ErrRet:
    return -1;
}

sai_status_t sai_remove_{{ table.name }}(_In_ sai_object_id_t {{ table.name }}_id) {
    if (RemoveFromTable({{ table.name }}_id)) {
        return 0;
    }
    return -1;
}

sai_status_t sai_set_{{ table.name }}_attribute (
        _In_ sai_object_id_t {{ table.name }}_id,
        _In_ const sai_attribute_t *attr) {
    assert(0 && "sai_set_{{ table.name }}_attribute NYI");
    return -1;
}

sai_status_t sai_get_{{ table.name }}_attribute(
        _In_ sai_object_id_t {{ table.name }}_id,
        _In_ uint32_t attr_count,
        _Inout_ sai_attribute_t *attr_list) {
    assert(0 && "sai_get_{{ table.name }}_attribute NYI");
    return -1;
}
{% else %}
sai_status_t sai_create_{{ table.name }}(
        _In_ const sai_{{ table.name }}_t *{{ table.name }},
        _In_ uint32_t attr_count,
        _In_ const sai_attribute_t *attr_list) { 
    p4::v1::TableEntry * matchActionEntry = new p4::v1::TableEntry();
    pi_p4_id_t tableId = {{table.id}};
    matchActionEntry->set_table_id(tableId);
    auto tableEntry = {{ table.name }};
    // There shall be one and only one action_type
    auto entry = matchActionEntry->mutable_action();
    auto action = entry->mutable_action();
    auto expectedParams = 0;
    auto matchedParams = 0;
    pi_p4_id_t actionId;
    grpc::StatusCode retCode;

    {% for key in table['keys'] %}
    {
        auto mf = matchActionEntry->add_match();
        mf->set_field_id({{key.id}});
        {% if key.match_type == 'exact' %}
        auto mf_exact = mf->mutable_exact();
        {{key.sai_key_field}}SetVal(tableEntry->{{ key.sai_key_name | lower }}, mf_exact, {{key.bitwidth}});
        {% elif key.match_type == 'lpm' %}
        auto mf_lpm = mf->mutable_lpm();
        {{key.sai_lpm_field}}SetVal(tableEntry->{{ key.sai_key_name | lower }}, mf_lpm, {{key.bitwidth}});
        {% elif key.match_type == 'list' %}
        assert(0 && "mutable_list is not supported");
        goto ErrRet;
        // auto mf1_list = mf1->mutable_xxx();
        //{{key.sai_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
        {% elif key.match_type == 'range_list' %}
        assert(0 && "range_list is not supported");
        goto ErrRet;
        // TODO: if it is ternary, need to set the mask
        // auto mf1_list = mf1->mutable_xxx();
        //{{key.sai_range_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
        {% endif %}
    }
    {% if 'v4_or_v6_id' in key %}
    {
        // set v4_or_v6 field
        auto mf = matchActionEntry->add_match();
        mf->set_field_id({{key.v4_or_v6_id}});
        auto mf_exact = mf->mutable_exact();
        booldataSetVal((tableEntry->{{ key.sai_key_name | lower }}.addr_family == SAI_IP_ADDR_FAMILY_IPV4) ? 0 : 1, mf_exact, 1);
    }
    {% endif %}
    {% endfor %}


    {% if table.actions|length == 1 %}
    {% for action in table.actions %}
    actionId = {{action.id}}; // SAI_{{ table.name | upper }}_ACTION_{{ action.name | upper }}
    expectedParams = {{ action.params|length }};
    {% endfor %}
    {% else %}
    // Search the action 
    for (uint32_t i = 0; i < attr_count; i++) {
        if (attr_list[i].id != SAI_{{ table.name | upper }}_ATTR_ACTION) {
            continue;
        }
        switch(attr_list[i].value.s32) {
            {% for action in table.actions %}
            case SAI_{{ table.name | upper }}_ACTION_{{ action.name | upper }}: {
                actionId = {{action.id}}; 
                expectedParams = {{ action.params|length }};
                break;
            }
            {% endfor %}
        }
        // only one action
        break;
    }
    {% endif %}
    action->set_action_id(actionId);

    for (uint32_t i = 0; i < attr_count; i++) {
        switch(attr_list[i].id) {
            {% for param in table.actionParams %}
            case SAI_{{ table.name | upper }}_ATTR_{{ param.name | upper }}: {
                auto param = action->add_params();
                param->set_param_id({{param.id}});
                {{param.field}}SetVal(attr_list[i].value, param, {{param.bitwidth}});
                matchedParams++;
                {% if 'v4_or_v6_id' in param %}
                {
                    // set v4_or_v6 field
                    auto param = action->add_params();
                    param->set_param_id({{param.v4_or_v6_id}});
                    booldataSetVal((attr_list[i].value.ipaddr.addr_family == SAI_IP_ADDR_FAMILY_IPV4) ? 0 : 1, param, 1);
                    matchedParams++;
                }
                {% endif %}
                break;
            }
            {% endfor %}
        }
    }
    
    assert((matchedParams == expectedParams)); 

    if (matchedParams != expectedParams) {
        goto ErrRet;
    }
    // TODO: ternaly needs to set priority
    retCode = MutateTableEntry(matchActionEntry, p4::v1::Update_Type_INSERT);
    if (grpc::StatusCode::OK == retCode) {
        delete matchActionEntry;
        return 0;
    }
ErrRet:
    delete matchActionEntry;
    return -1;
}

sai_status_t sai_remove_{{ table.name }}(
        _In_ const sai_{{ table.name }}_t *{{ table.name }}) { 
    p4::v1::TableEntry * matchActionEntry = new p4::v1::TableEntry();
    pi_p4_id_t tableId = {{table.id}};
    matchActionEntry->set_table_id(tableId);
    auto tableEntry =  {{ table.name }};
    grpc::StatusCode retCode;

    {% for key in table['keys'] %}
    {
        auto mf = matchActionEntry->add_match();
        mf->set_field_id({{key.id}});
        {% if key.match_type == 'exact' %}
        auto mf_exact = mf->mutable_exact();
        {{key.sai_key_field}}SetVal(tableEntry->{{ key.sai_key_name | lower }}, mf_exact, {{key.bitwidth}});
        {% elif key.match_type == 'lpm' %}
        auto mf_lpm = mf->mutable_lpm();
        {{key.sai_lpm_field}}SetVal(tableEntry->{{ key.sai_key_name | lower }}, mf_lpm, {{key.bitwidth}});
        {% elif key.match_type == 'list' %}
        assert(0 && "mutable_list is not supported");
        goto ErrRet;
        // auto mf1_list = mf1->mutable_xxx();
        //{{key.sai_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
        {% elif key.match_type == 'range_list' %}
        assert(0 && "range_list is not supported");
        goto ErrRet;
        // auto mf1_list = mf1->mutable_xxx();
        //{{key.sai_range_list_field}}SetVal(attr_list[i].value, mf1_list, {{key.bitwidth}});
        {% endif %}
    }
    {% if 'v4_or_v6_id' in key %}
    {
        // set v4_or_v6 field
        auto mf = matchActionEntry->add_match();
        mf->set_field_id({{key.v4_or_v6_id}});
        auto mf_exact = mf->mutable_exact();
        booldataSetVal((tableEntry->{{ key.sai_key_name | lower }}.addr_family == SAI_IP_ADDR_FAMILY_IPV4) ? 0 : 1, mf_exact, 1);
    }
    {% endif %}
    {% endfor %}

    retCode = MutateTableEntry(matchActionEntry, p4::v1::Update_Type_DELETE);
    if (grpc::StatusCode::OK == retCode) {
        delete matchActionEntry;
        return 0;
    }

ErrRet:

    delete matchActionEntry;
    return -1;
}

sai_status_t sai_set_{{ table.name }}_attribute(
        _In_ const sai_{{ table.name }}_t *{{ table.name }},
        _In_ const sai_attribute_t *attr) {
            assert(0 && "sai_set_{{ table.name }}_attribute NYI");
            return -1;
}

sai_status_t sai_get_{{ table.name }}_attribute(
        _In_ const sai_{{ table.name }}_t *{{ table.name }},
        _In_ uint32_t attr_count,
        _Inout_ sai_attribute_t *attr_list) {
            assert(0 && "sai_get_{{ table.name }}_attribute NYI");
            return -1;
}
{% endif %}
{% endfor %}

/* TODO [cs] Generate .h file for _impl to use within sai_api_query() */
sai_{{ app_name }}_api_t sai_{{app_name }}_api_impl = {
{% for table in tables %}
    .create_{{ table.name }} =  sai_create_{{ table.name }},
    .remove_{{ table.name }} = sai_remove_{{ table.name }},
    .set_{{ table.name }}_attribute = sai_set_{{ table.name }}_attribute,
    .get_{{ table.name }}_attribute = sai_get_{{ table.name }}_attribute,
{% endfor %}
};
